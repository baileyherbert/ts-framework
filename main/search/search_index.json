{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 TODO: An introduction to the framework, its purpose and goals, its features, and a quick start guide.","title":"Introduction"},{"location":"#introduction","text":"TODO: An introduction to the framework, its purpose and goals, its features, and a quick start guide.","title":"Introduction"},{"location":"applications/configuring-applications/","text":"Configuring applications \u00b6 TODO: How to configure the root application module and an overview of all available options.","title":"Configuring applications"},{"location":"applications/configuring-applications/#configuring-applications","text":"TODO: How to configure the root application module and an overview of all available options.","title":"Configuring applications"},{"location":"applications/managing-applications/","text":"Managing applications \u00b6 TODO: How to mount applications to the process, start and stop them manually, handle exceptions, etc.","title":"Managing applications"},{"location":"applications/managing-applications/#managing-applications","text":"TODO: How to mount applications to the process, start and stop them manually, handle exceptions, etc.","title":"Managing applications"},{"location":"applications/managing-modules/","text":"Managing modules \u00b6 TODO: How to check the status of and manually start and stop modules using an application's process manager, plus how to track the progress of modules as they work through their lifecycles.","title":"Managing modules"},{"location":"applications/managing-modules/#managing-modules","text":"TODO: How to check the status of and manually start and stop modules using an application's process manager, plus how to track the progress of modules as they work through their lifecycles.","title":"Managing modules"},{"location":"applications/sending-events/","text":"Sending events \u00b6 TODO: How to invoke events into an application, both internally and externally.","title":"Sending events"},{"location":"applications/sending-events/#sending-events","text":"TODO: How to invoke events into an application, both internally and externally.","title":"Sending events"},{"location":"applications/sending-requests/","text":"Sending requests \u00b6 TODO: How to send requests into an application and handle the response, both internally and externally.","title":"Sending requests"},{"location":"applications/sending-requests/#sending-requests","text":"TODO: How to send requests into an application and handle the response, both internally and externally.","title":"Sending requests"},{"location":"controllers/handling-events/","text":"Handling events \u00b6 TODO: How to handle service events from a controller class.","title":"Handling events"},{"location":"controllers/handling-events/#handling-events","text":"TODO: How to handle service events from a controller class.","title":"Handling events"},{"location":"controllers/handling-requests/","text":"Handling requests \u00b6 TODO: How to handle service requests from a controller class.","title":"Handling requests"},{"location":"controllers/handling-requests/#handling-requests","text":"TODO: How to handle service requests from a controller class.","title":"Handling requests"},{"location":"controllers/implementing-controllers/","text":"Implementing controllers \u00b6 TODO: How to implement controller classes and an overview of all available utilities.","title":"Implementing controllers"},{"location":"controllers/implementing-controllers/#implementing-controllers","text":"TODO: How to implement controller classes and an overview of all available utilities.","title":"Implementing controllers"},{"location":"controllers/using-attributes/","text":"Using attributes \u00b6 TODO: How to use attributes to implement functionality in a controller class.","title":"Using attributes"},{"location":"controllers/using-attributes/#using-attributes","text":"TODO: How to use attributes to implement functionality in a controller class.","title":"Using attributes"},{"location":"getting-started/creating-applications/","text":"Creating applications \u00b6 Create the application class \u00b6 Create a class called App to act as the root module of the application. This class will extend the abstract Application class exposed by the framework. You must then invoke the super () constructor to set the application's options. src/App.ts import { Application } from '@ts-framework/framework' ; export class App extends Application { public constructor () { super ({ imports : [], }); } } Starting the application \u00b6 With the root application module defined, let's edit the main entry file of your project such as main.ts and attach the application to the process. src/main.ts import { App } from './App' ; app . attach (); The attach () method is a shortcut that configures the logging level, attaches logging transports, intercepts terminational signals (for a graceful exit), and then starts the application.","title":"Creating applications"},{"location":"getting-started/creating-applications/#creating-applications","text":"","title":"Creating applications"},{"location":"getting-started/creating-applications/#create-the-application-class","text":"Create a class called App to act as the root module of the application. This class will extend the abstract Application class exposed by the framework. You must then invoke the super () constructor to set the application's options. src/App.ts import { Application } from '@ts-framework/framework' ; export class App extends Application { public constructor () { super ({ imports : [], }); } }","title":"Create the application class"},{"location":"getting-started/creating-applications/#starting-the-application","text":"With the root application module defined, let's edit the main entry file of your project such as main.ts and attach the application to the process. src/main.ts import { App } from './App' ; app . attach (); The attach () method is a shortcut that configures the logging level, attaches logging transports, intercepts terminational signals (for a graceful exit), and then starts the application.","title":"Starting the application"},{"location":"getting-started/creating-attributes/","text":"Creating attributes \u00b6 Introduction \u00b6 Here's where the fun really begins! Other frameworks solve particular problems. For example, Nest.js makes it simple to interface with a web server using decorators within controllers. On the other hand, this framework solves no particular problems \u2013 not a single one! Instead, you can build your own solutions to whatever problems you face using service attributes . Need @Get() and @Post() decorators? They can be written in minutes! The framework builds upon the attributes decoration concept introduced in my reflection library . If you're not familiar, attributes are simple classes that are easily converted into decorators, and a class instance is preserved for each decoration. Services have first-class integration with attributes. The framework tracks attribute instances and makes it extremely easy to query and interface with them. This guide will demonstrate how to create the @Get() , @Req() , and @Res() decorators and bind them to a service that spins up an express server. For the record, you don't actually need to do this yourself \u2013 check out the express integration . Create the decorators \u00b6 First and foremost, we'll create the @Get() decorator using an attribute. src/example/attributes/Get.ts import { Attribute , AttributeMethodEvent , Component } from '@ts-framework/framework' ; export const Get = Attribute . create ( class GetAttribute extends Attribute { public constructor ( public readonly path : string ) { super (); } public override onMethod ( event : AttributeMethodEvent < Component , any > ) {} }); Check the upstream documentation on attributes to learn how to easily write your own attributes. In short, by overriding onMethod() in our implementation, we've enabled the attribute to be used on methods, with the constructor argument path as its sole parameter. Create the helper tokens \u00b6 We'll also need the @Req() and @Res() decorators to make it easier to inject the express Request and Response types which don't have an equivalent class readily available for injection. src/example/decorators/Req.ts import { Token } from '@ts-framework/framework' ; export const Req = () => Token ( 'express:request' ); src/example/decorators/Res.ts import { Token } from '@ts-framework/framework' ; export const Res = () => Token ( 'express:response' ); To make this work, we'll need to tell the dependency container what values to inject for these tokens when we invoke the methods that use them. Fortunately, this is very easy to do with the framework's attribute system, as you're about to see. Create the service \u00b6 Create a new HttpService and register it in a module of your choosing. Then read over and implement the code show below. src/example/HttpService.ts import { PromiseCompletionSource , Service } from '@ts-framework/framework' ; import { ExampleModule } from './ExampleModule' ; import { Get } from './attributes/Get' ; import { Server } from 'http' ; import express from 'express' ; export class HttpService extends Service < ExampleModule > { private app = express (); private server? : Server ; protected override register () { // (1) for ( const registration of this . application . attributes . getMethods ( Get )) { this . app . get ( registration . first (). path , async ( req , res ) => { const dispatcher = registration . dispatcher . clone (); // (2) dispatcher . setTokenParameter ( 'express:request' , req ); // (3) dispatcher . setTokenParameter ( 'express:response' , res ); const response = await dispatcher . invoke (); // (4) if ( response ) { res . send ( response ); // (5) } }); } } protected override async start () { const source = new PromiseCompletionSource < void > (); this . server = this . app . listen ( 3000 , () => source . resolve ()); // (6) return source . promise ; } protected override async stop () { if ( this . server ) { const source = new PromiseCompletionSource < void > (); this . server . close (() => source . resolve ()); return source . promise ; } } } This is a special method that runs immediately before the service is started for the first time. It won't run again, making it great for slow, one-time operations like applying attributes. The registration object for method-based attributes exposes a dispatcher that can be used to easily invoke the method with dependency injection. We're making a clone to avoid contaminating the original dispatcher object. Here, we're overriding the injection behavior for these specific tokens, which we set with the decorators in the previous section. The container will inject these values for the parameters instead. This will invoke the controller method that registered the route and then forward its return value. We'll await this value just in case it's a promise. If the controller method returned anything, let's add it to the response and send it off. This makes it easier for controllers to send their responses. Here we do some magic to promisify the listen step. We'll repeat similar magic when closing the server. Using the attribute \u00b6 With the attribute and service configured, we can now easily configure and handle routes from any controller in the entire application! src/example/ExampleController.ts export class ExampleController extends Controller < ExampleModule > { @Get ( '/' ) public async index ( @Req () request : Request , @Res () response : Response ) { return 'Hello world!' ; } } Give localhost:3000 a view and you should see the familiar greeting. Conclusion \u00b6 I hope this demonstrates the versatility of this framework. In this manner, it's a framework to create other frameworks, and most of the magic relies on the attribute system. It should be possible to recreate Nest.js in its entirety, or to create an entirely different framework.","title":"Creating attributes"},{"location":"getting-started/creating-attributes/#creating-attributes","text":"","title":"Creating attributes"},{"location":"getting-started/creating-attributes/#introduction","text":"Here's where the fun really begins! Other frameworks solve particular problems. For example, Nest.js makes it simple to interface with a web server using decorators within controllers. On the other hand, this framework solves no particular problems \u2013 not a single one! Instead, you can build your own solutions to whatever problems you face using service attributes . Need @Get() and @Post() decorators? They can be written in minutes! The framework builds upon the attributes decoration concept introduced in my reflection library . If you're not familiar, attributes are simple classes that are easily converted into decorators, and a class instance is preserved for each decoration. Services have first-class integration with attributes. The framework tracks attribute instances and makes it extremely easy to query and interface with them. This guide will demonstrate how to create the @Get() , @Req() , and @Res() decorators and bind them to a service that spins up an express server. For the record, you don't actually need to do this yourself \u2013 check out the express integration .","title":"Introduction"},{"location":"getting-started/creating-attributes/#create-the-decorators","text":"First and foremost, we'll create the @Get() decorator using an attribute. src/example/attributes/Get.ts import { Attribute , AttributeMethodEvent , Component } from '@ts-framework/framework' ; export const Get = Attribute . create ( class GetAttribute extends Attribute { public constructor ( public readonly path : string ) { super (); } public override onMethod ( event : AttributeMethodEvent < Component , any > ) {} }); Check the upstream documentation on attributes to learn how to easily write your own attributes. In short, by overriding onMethod() in our implementation, we've enabled the attribute to be used on methods, with the constructor argument path as its sole parameter.","title":"Create the decorators"},{"location":"getting-started/creating-attributes/#create-the-helper-tokens","text":"We'll also need the @Req() and @Res() decorators to make it easier to inject the express Request and Response types which don't have an equivalent class readily available for injection. src/example/decorators/Req.ts import { Token } from '@ts-framework/framework' ; export const Req = () => Token ( 'express:request' ); src/example/decorators/Res.ts import { Token } from '@ts-framework/framework' ; export const Res = () => Token ( 'express:response' ); To make this work, we'll need to tell the dependency container what values to inject for these tokens when we invoke the methods that use them. Fortunately, this is very easy to do with the framework's attribute system, as you're about to see.","title":"Create the helper tokens"},{"location":"getting-started/creating-attributes/#create-the-service","text":"Create a new HttpService and register it in a module of your choosing. Then read over and implement the code show below. src/example/HttpService.ts import { PromiseCompletionSource , Service } from '@ts-framework/framework' ; import { ExampleModule } from './ExampleModule' ; import { Get } from './attributes/Get' ; import { Server } from 'http' ; import express from 'express' ; export class HttpService extends Service < ExampleModule > { private app = express (); private server? : Server ; protected override register () { // (1) for ( const registration of this . application . attributes . getMethods ( Get )) { this . app . get ( registration . first (). path , async ( req , res ) => { const dispatcher = registration . dispatcher . clone (); // (2) dispatcher . setTokenParameter ( 'express:request' , req ); // (3) dispatcher . setTokenParameter ( 'express:response' , res ); const response = await dispatcher . invoke (); // (4) if ( response ) { res . send ( response ); // (5) } }); } } protected override async start () { const source = new PromiseCompletionSource < void > (); this . server = this . app . listen ( 3000 , () => source . resolve ()); // (6) return source . promise ; } protected override async stop () { if ( this . server ) { const source = new PromiseCompletionSource < void > (); this . server . close (() => source . resolve ()); return source . promise ; } } } This is a special method that runs immediately before the service is started for the first time. It won't run again, making it great for slow, one-time operations like applying attributes. The registration object for method-based attributes exposes a dispatcher that can be used to easily invoke the method with dependency injection. We're making a clone to avoid contaminating the original dispatcher object. Here, we're overriding the injection behavior for these specific tokens, which we set with the decorators in the previous section. The container will inject these values for the parameters instead. This will invoke the controller method that registered the route and then forward its return value. We'll await this value just in case it's a promise. If the controller method returned anything, let's add it to the response and send it off. This makes it easier for controllers to send their responses. Here we do some magic to promisify the listen step. We'll repeat similar magic when closing the server.","title":"Create the service"},{"location":"getting-started/creating-attributes/#using-the-attribute","text":"With the attribute and service configured, we can now easily configure and handle routes from any controller in the entire application! src/example/ExampleController.ts export class ExampleController extends Controller < ExampleModule > { @Get ( '/' ) public async index ( @Req () request : Request , @Res () response : Response ) { return 'Hello world!' ; } } Give localhost:3000 a view and you should see the familiar greeting.","title":"Using the attribute"},{"location":"getting-started/creating-attributes/#conclusion","text":"I hope this demonstrates the versatility of this framework. In this manner, it's a framework to create other frameworks, and most of the magic relies on the attribute system. It should be possible to recreate Nest.js in its entirety, or to create an entirely different framework.","title":"Conclusion"},{"location":"getting-started/creating-controllers/","text":"Creating controllers \u00b6 Controllers are classes that handle events dispatched by the application's services. That might sound simple, but events in this framework come in many forms and controllers can easily become the stars of your application. Create the controller class \u00b6 Create a class called ExampleController alongside its parent module that looks like the following: src/example/ExampleController.ts import { Injectable , Controller } from '@ts-framework/framework' ; import { ExampleModule } from './ExampleModule' ; @Injectable () export class ExampleController extends Controller < ExampleModule > { } For now, there's nothing to put in the controller, so we'll keep it empty. The next guide will modify the service to emit events, and show how to handle those events in the controller. Import the controller \u00b6 Go back to the ExampleModule.ts file and add the new class to the controllers array. src/example/ExampleModule.ts import { Module } from '@ts-framework/framework' ; import { App } from '../App' ; import { ExampleService } from './ExampleService' ; import { ExampleController } from './ExampleController' ; export class ExampleModule extends Module < App > { public constructor () { super ({ imports : [], services : [ ExampleService ], controllers : [ ExampleController ], }); } }","title":"Creating controllers"},{"location":"getting-started/creating-controllers/#creating-controllers","text":"Controllers are classes that handle events dispatched by the application's services. That might sound simple, but events in this framework come in many forms and controllers can easily become the stars of your application.","title":"Creating controllers"},{"location":"getting-started/creating-controllers/#create-the-controller-class","text":"Create a class called ExampleController alongside its parent module that looks like the following: src/example/ExampleController.ts import { Injectable , Controller } from '@ts-framework/framework' ; import { ExampleModule } from './ExampleModule' ; @Injectable () export class ExampleController extends Controller < ExampleModule > { } For now, there's nothing to put in the controller, so we'll keep it empty. The next guide will modify the service to emit events, and show how to handle those events in the controller.","title":"Create the controller class"},{"location":"getting-started/creating-controllers/#import-the-controller","text":"Go back to the ExampleModule.ts file and add the new class to the controllers array. src/example/ExampleModule.ts import { Module } from '@ts-framework/framework' ; import { App } from '../App' ; import { ExampleService } from './ExampleService' ; import { ExampleController } from './ExampleController' ; export class ExampleModule extends Module < App > { public constructor () { super ({ imports : [], services : [ ExampleService ], controllers : [ ExampleController ], }); } }","title":"Import the controller"},{"location":"getting-started/creating-events/","text":"Creating events \u00b6 This framework introduces a simple concept called service events that makes it extremely easy to listen to and handle events from anywhere in your application. As the name implies, these events typically originate from services as part of their background work. Traditionally, events in the JavaScript ecosystem have used strings as their identifiers. This leads to some difficulty when dealing with collisions and type hinting. Here, we use classes instead of strings for our events, and this solves both of those problems. Create the event namespace \u00b6 The current convention is export a service's events within a namespace. Let's create a simple ExampleEvent namespace within our module's directory. You can skip this step if you'd like. src/example/ExampleEvent.ts export namespace ExampleEvent { } Create the event class \u00b6 Now export a class inside the namespace, making sure to extend the base Event<T> class. If the T decorator is not supplied, the event will not accept any data, otherwise you may specify the type of data it accepts. Let's create an event called ExampleEvent.IntervalInvoked that accepts an object as its data type. Inside this object, we'll pass a random number, because why not? src/example/ExampleEvent.ts import { Event } from '@ts-framework/framework' ; export namespace ExampleEvent { /** * Emitted when the example service's interval is invoked. The service * will generate and pass a random number with each invocation. */ export class Interval extends Event < { randomNumber : number } > {} } Handle the event \u00b6 Let's go back to the ExampleController class and add a method to handle this event. You can give this method any name, as long as it has the @EventHandler decorator and accepts the event as its sole argument. src/example/ExampleController.ts import { Injectable , Controller , EventHandler } from '@ts-framework/framework' ; import { ExampleModule } from './ExampleModule' ; @Injectable () export class ExampleController extends Controller < ExampleModule > { @EventHandler public onInterval ( event : ExampleEvent.Interval ) { this . logger . info ( 'Got an invocation with random number:' , event . data . randomNumber ); } } Emit the event \u00b6 Now let's go back to the ExampleService class and change the interval's callback to generate a random number and emit the event. src/example/ExampleService.ts import { Injectable , Service } from '@ts-framework/framework' ; import { ExampleModule } from './ExampleModule' ; import { ExampleEvent } from './ExampleEvent' ; @Injectable () export class ExampleService extends Service < ExampleModule > { private interval? : NodeJS.Timeout ; public constructor () { super (); } protected override async start () { this . logger . info ( 'Creating the interval' ); this . interval = setInterval (() => { this . emit ( ExampleEvent . Interval , { randomNumber : Math.floor ( Math . random () * 1000 ) }); }, 1000 ); } protected override async stop () { if ( this . interval ) { this . logger . info ( 'Clearing the interval' ); clearInterval ( this . interval ); } } } After saving and running with the new changes, you will immediately see the controller logging a new random number with each passing second. Learn more \u00b6 Events are emitted globally and can be handled by controllers across the application, including in unrelated modules. This is possible due to the fact that each event class is its own unique signature, thus preventing collisions. You can also emit and listen for events manually using the application's event manager, however using the emit() method inside services is preferred. // Emitting events app . events . emit ( ExampleEvent . Interval , { randomNumber : 0 }); // Listening to events app . events . on ( ExampleEvent . Interval , event => { console . log ( event . data . randomNumber ); }); For more advanced usage details, check out the complete service events guide .","title":"Creating events"},{"location":"getting-started/creating-events/#creating-events","text":"This framework introduces a simple concept called service events that makes it extremely easy to listen to and handle events from anywhere in your application. As the name implies, these events typically originate from services as part of their background work. Traditionally, events in the JavaScript ecosystem have used strings as their identifiers. This leads to some difficulty when dealing with collisions and type hinting. Here, we use classes instead of strings for our events, and this solves both of those problems.","title":"Creating events"},{"location":"getting-started/creating-events/#create-the-event-namespace","text":"The current convention is export a service's events within a namespace. Let's create a simple ExampleEvent namespace within our module's directory. You can skip this step if you'd like. src/example/ExampleEvent.ts export namespace ExampleEvent { }","title":"Create the event namespace"},{"location":"getting-started/creating-events/#create-the-event-class","text":"Now export a class inside the namespace, making sure to extend the base Event<T> class. If the T decorator is not supplied, the event will not accept any data, otherwise you may specify the type of data it accepts. Let's create an event called ExampleEvent.IntervalInvoked that accepts an object as its data type. Inside this object, we'll pass a random number, because why not? src/example/ExampleEvent.ts import { Event } from '@ts-framework/framework' ; export namespace ExampleEvent { /** * Emitted when the example service's interval is invoked. The service * will generate and pass a random number with each invocation. */ export class Interval extends Event < { randomNumber : number } > {} }","title":"Create the event class"},{"location":"getting-started/creating-events/#handle-the-event","text":"Let's go back to the ExampleController class and add a method to handle this event. You can give this method any name, as long as it has the @EventHandler decorator and accepts the event as its sole argument. src/example/ExampleController.ts import { Injectable , Controller , EventHandler } from '@ts-framework/framework' ; import { ExampleModule } from './ExampleModule' ; @Injectable () export class ExampleController extends Controller < ExampleModule > { @EventHandler public onInterval ( event : ExampleEvent.Interval ) { this . logger . info ( 'Got an invocation with random number:' , event . data . randomNumber ); } }","title":"Handle the event"},{"location":"getting-started/creating-events/#emit-the-event","text":"Now let's go back to the ExampleService class and change the interval's callback to generate a random number and emit the event. src/example/ExampleService.ts import { Injectable , Service } from '@ts-framework/framework' ; import { ExampleModule } from './ExampleModule' ; import { ExampleEvent } from './ExampleEvent' ; @Injectable () export class ExampleService extends Service < ExampleModule > { private interval? : NodeJS.Timeout ; public constructor () { super (); } protected override async start () { this . logger . info ( 'Creating the interval' ); this . interval = setInterval (() => { this . emit ( ExampleEvent . Interval , { randomNumber : Math.floor ( Math . random () * 1000 ) }); }, 1000 ); } protected override async stop () { if ( this . interval ) { this . logger . info ( 'Clearing the interval' ); clearInterval ( this . interval ); } } } After saving and running with the new changes, you will immediately see the controller logging a new random number with each passing second.","title":"Emit the event"},{"location":"getting-started/creating-events/#learn-more","text":"Events are emitted globally and can be handled by controllers across the application, including in unrelated modules. This is possible due to the fact that each event class is its own unique signature, thus preventing collisions. You can also emit and listen for events manually using the application's event manager, however using the emit() method inside services is preferred. // Emitting events app . events . emit ( ExampleEvent . Interval , { randomNumber : 0 }); // Listening to events app . events . on ( ExampleEvent . Interval , event => { console . log ( event . data . randomNumber ); }); For more advanced usage details, check out the complete service events guide .","title":"Learn more"},{"location":"getting-started/creating-modules/","text":"Creating modules \u00b6 This framework uses a concept called modules to help organize code. You'll want to bundle related services, controllers, utilities, and other code together inside modules. You can also create nested modules to break down complex logic into smaller parts. You've already created your first module in fact \u2013 the root application class is actually a module, and it can even host its own services and controllers, although this is not recommended as it's best to put those in dedicated modules instead. File structure \u00b6 It's important to have an idea on the file structure you'd like to use. The general convention around here is something like this: src/ \u251c\u2500\u2500 example/ \u2502 \u251c\u2500\u2500 ExampleController.ts \u2502 \u251c\u2500\u2500 ExampleModule.ts \u2502 \u2514\u2500\u2500 ExampleService.ts \u251c\u2500\u2500 advanced/ \u2502 \u251c\u2500\u2500 controllers/ \u2502 \u2502 \u251c\u2500\u2500 AdvancedController1.ts \u2502 \u2502 \u2514\u2500\u2500 AdvancedController2.ts \u2502 \u251c\u2500\u2500 modules/ \u2502 \u2502 \u251c\u2500\u2500 submodule1/ \u2502 \u2502 \u2514\u2500\u2500 submodule2/ \u2502 \u251c\u2500\u2500 services/ \u2502 \u2502 \u251c\u2500\u2500 AdvancedService1.ts \u2502 \u2502 \u2514\u2500\u2500 AdvancedService2.ts \u2502 \u2514\u2500\u2500 AdvancedModule.ts \u251c\u2500\u2500 App.ts \u2514\u2500\u2500 main.ts Feel free to use whatever file structure works best for you! Create the module class \u00b6 Create a class called ExampleModule that looks like the following: src/example/ExampleModule.ts import { Module } from '@ts-framework/framework' ; import { App } from '../App' ; export class ExampleModule extends Module < App > { public constructor () { super ({ imports : [], services : [], controllers : [], }); } } Note the generic in the parent class Module < App > . It's not required, but you should always add a generic pointing to the parent in the hierarchy, all the way up to the root application. This will unlock some extra type hinting that will come in handy later. Import the module \u00b6 With the module's class defined, now we must import it inside a parent module. Let's go back and import it inside the root application module: src/App.ts import { Application } from '@ts-framework/framework' ; import { ExampleModule } from './example/ExampleModule' ; export class App extends Application { public constructor () { super ({ imports : [ ExampleModule ], }); } }","title":"Creating modules"},{"location":"getting-started/creating-modules/#creating-modules","text":"This framework uses a concept called modules to help organize code. You'll want to bundle related services, controllers, utilities, and other code together inside modules. You can also create nested modules to break down complex logic into smaller parts. You've already created your first module in fact \u2013 the root application class is actually a module, and it can even host its own services and controllers, although this is not recommended as it's best to put those in dedicated modules instead.","title":"Creating modules"},{"location":"getting-started/creating-modules/#file-structure","text":"It's important to have an idea on the file structure you'd like to use. The general convention around here is something like this: src/ \u251c\u2500\u2500 example/ \u2502 \u251c\u2500\u2500 ExampleController.ts \u2502 \u251c\u2500\u2500 ExampleModule.ts \u2502 \u2514\u2500\u2500 ExampleService.ts \u251c\u2500\u2500 advanced/ \u2502 \u251c\u2500\u2500 controllers/ \u2502 \u2502 \u251c\u2500\u2500 AdvancedController1.ts \u2502 \u2502 \u2514\u2500\u2500 AdvancedController2.ts \u2502 \u251c\u2500\u2500 modules/ \u2502 \u2502 \u251c\u2500\u2500 submodule1/ \u2502 \u2502 \u2514\u2500\u2500 submodule2/ \u2502 \u251c\u2500\u2500 services/ \u2502 \u2502 \u251c\u2500\u2500 AdvancedService1.ts \u2502 \u2502 \u2514\u2500\u2500 AdvancedService2.ts \u2502 \u2514\u2500\u2500 AdvancedModule.ts \u251c\u2500\u2500 App.ts \u2514\u2500\u2500 main.ts Feel free to use whatever file structure works best for you!","title":"File structure"},{"location":"getting-started/creating-modules/#create-the-module-class","text":"Create a class called ExampleModule that looks like the following: src/example/ExampleModule.ts import { Module } from '@ts-framework/framework' ; import { App } from '../App' ; export class ExampleModule extends Module < App > { public constructor () { super ({ imports : [], services : [], controllers : [], }); } } Note the generic in the parent class Module < App > . It's not required, but you should always add a generic pointing to the parent in the hierarchy, all the way up to the root application. This will unlock some extra type hinting that will come in handy later.","title":"Create the module class"},{"location":"getting-started/creating-modules/#import-the-module","text":"With the module's class defined, now we must import it inside a parent module. Let's go back and import it inside the root application module: src/App.ts import { Application } from '@ts-framework/framework' ; import { ExampleModule } from './example/ExampleModule' ; export class App extends Application { public constructor () { super ({ imports : [ ExampleModule ], }); } }","title":"Import the module"},{"location":"getting-started/creating-services/","text":"Creating services \u00b6 Services are special classes that host some kind of background activity or process. They can be started and gracefully stopped upon request, and can even extend the functionality of the framework through the attributes system (more on that later). Create the service class \u00b6 Create a class called ExampleService alongside its parent module that looks like the following: src/example/ExampleService.ts import { Injectable , Service } from '@ts-framework/framework' ; import { ExampleModule } from './ExampleModule' ; @Injectable () export class ExampleService extends Service < ExampleModule > { private interval? : NodeJS.Timeout ; public constructor () { super (); } protected override async start () { this . logger . info ( 'Creating the interval' ); this . interval = setInterval (() => { this . logger . info ( 'The interval callback was invoked!' ); }, 1000 ); } protected override async stop () { if ( this . interval ) { this . logger . info ( 'Clearing the interval' ); clearInterval ( this . interval ); } } } This simple service starts a one-second interval that prints a message to the output each time. When the service is stopped, the interval is cleared using clearInterval() . Stopping a service safely \u00b6 Note how the stop() method defined above checks if this . interval has been initialized before attempting to clear it. This is an extremely important concept. Imagine this \u2013 the start() method above is called. However, before we have a chance to initialize the interval, an error is thrown by some other code before it. The start has failed. When a service fails to start, the framework will immediately call the stop() method for us to clear anything that was initialized before the error. Import the service \u00b6 Go back to the ExampleModule.ts file and add the new class to the services array. src/example/ExampleModule.ts import { Module } from '@ts-framework/framework' ; import { App } from '../App' ; import { ExampleService } from './ExampleService' ; export class ExampleModule extends Module < App > { public constructor () { super ({ imports : [], services : [ ExampleService ], controllers : [], }); } }","title":"Creating services"},{"location":"getting-started/creating-services/#creating-services","text":"Services are special classes that host some kind of background activity or process. They can be started and gracefully stopped upon request, and can even extend the functionality of the framework through the attributes system (more on that later).","title":"Creating services"},{"location":"getting-started/creating-services/#create-the-service-class","text":"Create a class called ExampleService alongside its parent module that looks like the following: src/example/ExampleService.ts import { Injectable , Service } from '@ts-framework/framework' ; import { ExampleModule } from './ExampleModule' ; @Injectable () export class ExampleService extends Service < ExampleModule > { private interval? : NodeJS.Timeout ; public constructor () { super (); } protected override async start () { this . logger . info ( 'Creating the interval' ); this . interval = setInterval (() => { this . logger . info ( 'The interval callback was invoked!' ); }, 1000 ); } protected override async stop () { if ( this . interval ) { this . logger . info ( 'Clearing the interval' ); clearInterval ( this . interval ); } } } This simple service starts a one-second interval that prints a message to the output each time. When the service is stopped, the interval is cleared using clearInterval() .","title":"Create the service class"},{"location":"getting-started/creating-services/#stopping-a-service-safely","text":"Note how the stop() method defined above checks if this . interval has been initialized before attempting to clear it. This is an extremely important concept. Imagine this \u2013 the start() method above is called. However, before we have a chance to initialize the interval, an error is thrown by some other code before it. The start has failed. When a service fails to start, the framework will immediately call the stop() method for us to clear anything that was initialized before the error.","title":"Stopping a service safely"},{"location":"getting-started/creating-services/#import-the-service","text":"Go back to the ExampleModule.ts file and add the new class to the services array. src/example/ExampleModule.ts import { Module } from '@ts-framework/framework' ; import { App } from '../App' ; import { ExampleService } from './ExampleService' ; export class ExampleModule extends Module < App > { public constructor () { super ({ imports : [], services : [ ExampleService ], controllers : [], }); } }","title":"Import the service"},{"location":"getting-started/installation/","text":"Installation \u00b6 TODO: How to install the framework (standalone, with other frameworks, and into existing projects).","title":"Installation"},{"location":"getting-started/installation/#installation","text":"TODO: How to install the framework (standalone, with other frameworks, and into existing projects).","title":"Installation"},{"location":"integrations/discord/","text":"Discord \u00b6 TODO: How to use the @ts-framework/discord package to build a discord bot, using controllers to handle commands and events.","title":"Discord"},{"location":"integrations/discord/#discord","text":"TODO: How to use the @ts-framework/discord package to build a discord bot, using controllers to handle commands and events.","title":"Discord"},{"location":"integrations/express/","text":"Express \u00b6 TODO: How to use the @ts-framework/express package to build a web application, using controllers to both build and handle routes.","title":"Express"},{"location":"integrations/express/#express","text":"TODO: How to use the @ts-framework/express package to build a web application, using controllers to both build and handle routes.","title":"Express"},{"location":"modules/configuring-modules/","text":"Configuring modules \u00b6 TODO: How to configure modules and an overview of all available options.","title":"Configuring modules"},{"location":"modules/configuring-modules/#configuring-modules","text":"TODO: How to configure modules and an overview of all available options.","title":"Configuring modules"},{"location":"modules/importing-modules/","text":"Importing modules \u00b6 TODO: How to import modules from a third party package.","title":"Importing modules"},{"location":"modules/importing-modules/#importing-modules","text":"TODO: How to import modules from a third party package.","title":"Importing modules"},{"location":"modules/lifecycle-methods/","text":"Lifecycle methods \u00b6 TODO: How to implement lifecycle methods into modules and an overview of all available methods.","title":"Lifecycle methods"},{"location":"modules/lifecycle-methods/#lifecycle-methods","text":"TODO: How to implement lifecycle methods into modules and an overview of all available methods.","title":"Lifecycle methods"},{"location":"modules/publishing-modules/","text":"Publishing modules \u00b6 TODO: How to publish a module to a package manager (npm) for third party consumption.","title":"Publishing modules"},{"location":"modules/publishing-modules/#publishing-modules","text":"TODO: How to publish a module to a package manager (npm) for third party consumption.","title":"Publishing modules"},{"location":"services/adding-attributes/","text":"Adding attributes \u00b6 TODO: How to create and implement service attributes.","title":"Adding attributes"},{"location":"services/adding-attributes/#adding-attributes","text":"TODO: How to create and implement service attributes.","title":"Adding attributes"},{"location":"services/adding-events/","text":"Adding events \u00b6 TODO: How to create and invoke service events.","title":"Adding events"},{"location":"services/adding-events/#adding-events","text":"TODO: How to create and invoke service events.","title":"Adding events"},{"location":"services/adding-requests/","text":"Adding requests \u00b6 TODO: How to create and invoke service requests.","title":"Adding requests"},{"location":"services/adding-requests/#adding-requests","text":"TODO: How to create and invoke service requests.","title":"Adding requests"},{"location":"services/implementing-services/","text":"Implementing services \u00b6 TODO: How to implement service classes and an overview of all available methods and utilities.","title":"Implementing services"},{"location":"services/implementing-services/#implementing-services","text":"TODO: How to implement service classes and an overview of all available methods and utilities.","title":"Implementing services"},{"location":"techniques/configuration/","text":"Configuration \u00b6 The framework uses environment variables for its configuration. Each module in the application has an opportunity to define the environment variables it would like to use. These variables are then validated and guaranteed to exist. Adding configuration to a module \u00b6 To declare a module's environment configuration, extend the protected onEnvironment() method. You will receive an instance of EnvironmentManager and are then expected to return the values of your variables using the rules() method on that instance. class ExampleModule extends Module < App > { protected override onEnvironment ( env : EnvironmentManager ) { return env . rules ({ TOKEN : env.schema.string () }); } } With the above example, the application will not start unless the TOKEN is available either in the .env file or as part of the process environment. You can learn more about declaring and validating these variables at @baileyherbert/env . Accessing the configuration \u00b6 You can retrieve values from a module's configuration using its env property if you have a reference to it. The below example shows how to do this from a service, assuming the Service<T> generic is configured properly. public override async start () { const token = this . module .env.TOKEN ; } Note that these environment variables are available globally across the application and multiple modules can use the same names. This also means you can retrieve the value using an environment manager which is commonly exposed as an environment property. public override async start () { const token = this . module .environment.get ( 'TOKEN' ); const token = this . application . environment . get ( 'TOKEN' ); } Setting values on imports \u00b6 It's possible to set or override the values of environment variables for specific modules (and their children) when importing them. export class App extends Application { public constructor () { super ({ imports : [ ExampleModule . withEnvironment ({ TOKEN : 'Sets or overrides the value' }) ] }); } } In these cases, the module's environment and env properties will see the overridden value, but the rest of the application will not. This makes it great for module-specific configuration, and the values can be any type! Note that these custom values remain subject to validation by the imported module or its children via their onEnvironment() methods. Setting values on the application \u00b6 When starting or attaching the application, you have an opportunity to set or override its environment variables without affecting the rest of the application (or other instances of the framework). app . start ({ environment : { TOKEN : 'Sets or overrides the value' } });","title":"Configuration"},{"location":"techniques/configuration/#configuration","text":"The framework uses environment variables for its configuration. Each module in the application has an opportunity to define the environment variables it would like to use. These variables are then validated and guaranteed to exist.","title":"Configuration"},{"location":"techniques/configuration/#adding-configuration-to-a-module","text":"To declare a module's environment configuration, extend the protected onEnvironment() method. You will receive an instance of EnvironmentManager and are then expected to return the values of your variables using the rules() method on that instance. class ExampleModule extends Module < App > { protected override onEnvironment ( env : EnvironmentManager ) { return env . rules ({ TOKEN : env.schema.string () }); } } With the above example, the application will not start unless the TOKEN is available either in the .env file or as part of the process environment. You can learn more about declaring and validating these variables at @baileyherbert/env .","title":"Adding configuration to a module"},{"location":"techniques/configuration/#accessing-the-configuration","text":"You can retrieve values from a module's configuration using its env property if you have a reference to it. The below example shows how to do this from a service, assuming the Service<T> generic is configured properly. public override async start () { const token = this . module .env.TOKEN ; } Note that these environment variables are available globally across the application and multiple modules can use the same names. This also means you can retrieve the value using an environment manager which is commonly exposed as an environment property. public override async start () { const token = this . module .environment.get ( 'TOKEN' ); const token = this . application . environment . get ( 'TOKEN' ); }","title":"Accessing the configuration"},{"location":"techniques/configuration/#setting-values-on-imports","text":"It's possible to set or override the values of environment variables for specific modules (and their children) when importing them. export class App extends Application { public constructor () { super ({ imports : [ ExampleModule . withEnvironment ({ TOKEN : 'Sets or overrides the value' }) ] }); } } In these cases, the module's environment and env properties will see the overridden value, but the rest of the application will not. This makes it great for module-specific configuration, and the values can be any type! Note that these custom values remain subject to validation by the imported module or its children via their onEnvironment() methods.","title":"Setting values on imports"},{"location":"techniques/configuration/#setting-values-on-the-application","text":"When starting or attaching the application, you have an opportunity to set or override its environment variables without affecting the rest of the application (or other instances of the framework). app . start ({ environment : { TOKEN : 'Sets or overrides the value' } });","title":"Setting values on the application"},{"location":"techniques/logging/","text":"Logging \u00b6 This framework has a sweet little logging utility that is easy to access from virtually anywhere, and is highly configurable. Retrieving loggers \u00b6 Each service, controller, and module in the application has a built-in logger that can be accessed with the protected logger property. For example: public override async start () { this . logger . info ( 'Starting the service!' ); } Writing output \u00b6 There are six different logging levels that can be used for output: this . logger . trace ( 'For the most detailed output' ); this . logger . debug ( 'For investigation during development' ); this . logger . info ( 'For tracking the flow of the app' ); this . logger . warning ( 'For abnormal or unexpected events' ); this . logger . error ( 'For failures that cause an activity to stop' ); this . logger . critical ( 'For unrecoverable crashes and failures' ); Logging levels \u00b6 You can adjust the logging level of each module as part of the module's configuration. You can also override this configuration and enforce a logging level when importing a module. From module configuration \u00b6 To set the logging level of a module from its configuration: export class ExampleModule extends Module < App > { public constructor () { super ({ logging : LogLevel.Information , imports : [], }); } } From module imports \u00b6 To enforce a logging level on a module when importing it: super ({ imports : [ ExampleModule . withOptions ({ logging : LogLevel.Information }) ] }) From application start \u00b6 To enforce a logging level on the entire application when attaching it: app . attach ({ loggingLevel : LogLevel.Information }) Logger hierarchy \u00b6 It's important to understand the logger hierarchy when working with logging levels. All of the loggers in your application are connected together in a tree-like structure, with the root application module's logger acting as the entry point. Say you have a deeply nested service like this list: App -> ExampleModule -> NestedModule -> NestedService When the NestedService emits output using its logger, the output will propagate up the chain until it reaches the logger for the root App module. As it travels up this chain, it will be subject to each logger's configured logging level. This means that when the NestedService emits output of the Debug level, it wouldn't arrive to the root logger where it can be printed if any other logger between the two had a higher configured logging level than Debug . Tip This design allows you to limit the amount of output that modules produce, allowing you to build and import noisy and debug-heavy modules without having to limit the rest of your application. For this system to work best, avoid configuring logging levels on your modules unless necessary. If you configure too many modules, it will become difficult to track and modify in the future. Logging to a file \u00b6 With the attach () method \u00b6 When using the attach() method to start the application, you can specify an array of logging transports as part of the attachment options. However, doing so will completely override the default transport (console), so we'll need to add both. app . attach ({ loggingTransports : [ new ConsoleTransport (), new FileTransport ({ fileName : 'console.log' }) ] }); You can customize the minimum logging level individually for each transport as well by passing the logging level as the first parameter, such as: new FileTransport ( LogLevel . Error , { fileName : 'console.log' }) Note that the file transport has built-in automatic rotation that can be configured. Check out the transport documentation for the full details. With the start () method \u00b6 You can use the built-in createFileTransport method on the logger when starting manually. const app = AppFactory . create ( App ); app . logger . createFileTransport ({ fileName : 'console.log' }); app . start (); Learn more \u00b6 Check out the full documentation for the logging library to learn more, such as how to customize the prefixes and how to create your own transports (destinations) for output.","title":"Logging"},{"location":"techniques/logging/#logging","text":"This framework has a sweet little logging utility that is easy to access from virtually anywhere, and is highly configurable.","title":"Logging"},{"location":"techniques/logging/#retrieving-loggers","text":"Each service, controller, and module in the application has a built-in logger that can be accessed with the protected logger property. For example: public override async start () { this . logger . info ( 'Starting the service!' ); }","title":"Retrieving loggers"},{"location":"techniques/logging/#writing-output","text":"There are six different logging levels that can be used for output: this . logger . trace ( 'For the most detailed output' ); this . logger . debug ( 'For investigation during development' ); this . logger . info ( 'For tracking the flow of the app' ); this . logger . warning ( 'For abnormal or unexpected events' ); this . logger . error ( 'For failures that cause an activity to stop' ); this . logger . critical ( 'For unrecoverable crashes and failures' );","title":"Writing output"},{"location":"techniques/logging/#logging-levels","text":"You can adjust the logging level of each module as part of the module's configuration. You can also override this configuration and enforce a logging level when importing a module.","title":"Logging levels"},{"location":"techniques/logging/#from-module-configuration","text":"To set the logging level of a module from its configuration: export class ExampleModule extends Module < App > { public constructor () { super ({ logging : LogLevel.Information , imports : [], }); } }","title":"From module configuration"},{"location":"techniques/logging/#from-module-imports","text":"To enforce a logging level on a module when importing it: super ({ imports : [ ExampleModule . withOptions ({ logging : LogLevel.Information }) ] })","title":"From module imports"},{"location":"techniques/logging/#from-application-start","text":"To enforce a logging level on the entire application when attaching it: app . attach ({ loggingLevel : LogLevel.Information })","title":"From application start"},{"location":"techniques/logging/#logger-hierarchy","text":"It's important to understand the logger hierarchy when working with logging levels. All of the loggers in your application are connected together in a tree-like structure, with the root application module's logger acting as the entry point. Say you have a deeply nested service like this list: App -> ExampleModule -> NestedModule -> NestedService When the NestedService emits output using its logger, the output will propagate up the chain until it reaches the logger for the root App module. As it travels up this chain, it will be subject to each logger's configured logging level. This means that when the NestedService emits output of the Debug level, it wouldn't arrive to the root logger where it can be printed if any other logger between the two had a higher configured logging level than Debug . Tip This design allows you to limit the amount of output that modules produce, allowing you to build and import noisy and debug-heavy modules without having to limit the rest of your application. For this system to work best, avoid configuring logging levels on your modules unless necessary. If you configure too many modules, it will become difficult to track and modify in the future.","title":"Logger hierarchy"},{"location":"techniques/logging/#logging-to-a-file","text":"","title":"Logging to a file"},{"location":"techniques/logging/#with-the-attach-method","text":"When using the attach() method to start the application, you can specify an array of logging transports as part of the attachment options. However, doing so will completely override the default transport (console), so we'll need to add both. app . attach ({ loggingTransports : [ new ConsoleTransport (), new FileTransport ({ fileName : 'console.log' }) ] }); You can customize the minimum logging level individually for each transport as well by passing the logging level as the first parameter, such as: new FileTransport ( LogLevel . Error , { fileName : 'console.log' }) Note that the file transport has built-in automatic rotation that can be configured. Check out the transport documentation for the full details.","title":"With the attach() method"},{"location":"techniques/logging/#with-the-start-method","text":"You can use the built-in createFileTransport method on the logger when starting manually. const app = AppFactory . create ( App ); app . logger . createFileTransport ({ fileName : 'console.log' }); app . start ();","title":"With the start() method"},{"location":"techniques/logging/#learn-more","text":"Check out the full documentation for the logging library to learn more, such as how to customize the prefixes and how to create your own transports (destinations) for output.","title":"Learn more"},{"location":"techniques/queues/","text":"Queues \u00b6 TODO: How to implement queues into an application with the @ts-framework/queue package.","title":"Queues"},{"location":"techniques/queues/#queues","text":"TODO: How to implement queues into an application with the @ts-framework/queue package.","title":"Queues"},{"location":"techniques/scheduling/","text":"Scheduling \u00b6 TODO: How to implement task scheduling into an application with the @ts-framework/scheduler package.","title":"Scheduling"},{"location":"techniques/scheduling/#scheduling","text":"TODO: How to implement task scheduling into an application with the @ts-framework/scheduler package.","title":"Scheduling"},{"location":"techniques/storage/","text":"Storage \u00b6 TODO: How to implement state and file storage into an application with the @ts-framework/storage package.","title":"Storage"},{"location":"techniques/storage/#storage","text":"TODO: How to implement state and file storage into an application with the @ts-framework/storage package.","title":"Storage"}]}